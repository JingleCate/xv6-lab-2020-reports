diff --git a/kernel/defs.h b/kernel/defs.h
index 3564db4..2f487fd 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -170,6 +170,11 @@ uint64          walkaddr(pagetable_t, uint64);
 int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
+void            vmprint(pagetable_t pagetable);
+void            uvmmap(pagetable_t pagetable, uint64 va, uint64 pa, uint64 sz, int perm);
+pagetable_t     proc_kpt_init();
+pte_t*          walk(pagetable_t pagetable, uint64 va, int alloc);
+void            uvm_user2ker_copy(pagetable_t u, pagetable_t k, uint64 start, uint64 end);
 
 // plic.c
 void            plicinit(void);
diff --git a/kernel/exec.c b/kernel/exec.c
index d62d29d..4057a07 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -51,6 +51,11 @@ exec(char *path, char **argv)
     uint64 sz1;
     if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0)
       goto bad;
+
+    //判断是否越界
+    if(sz1 > PLIC)
+      goto bad;
+
     sz = sz1;
     if((ph.vaddr % PGSIZE) != 0)
       goto bad;
@@ -116,6 +121,10 @@ exec(char *path, char **argv)
   p->trapframe->sp = sp; // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
 
+  uvm_user2ker_copy(p->pagetable, p->kernelpt, 0, sz);
+
+  if(p->pid==1)
+    vmprint(p->pagetable);
   return argc; // this ends up in a0, the first argument to main(argc, argv)
 
  bad:
diff --git a/kernel/proc.c b/kernel/proc.c
index 22e7ce4..350b74b 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -20,6 +20,9 @@ static void freeproc(struct proc *p);
 
 extern char trampoline[]; // trampoline.S
 
+void proc_freekpt(pagetable_t pagetable);
+extern pagetable_t kernel_pagetable;
+
 // helps ensure that wakeups of wait()ing
 // parents are not lost. helps obey the
 // memory model when using p->parent.
@@ -135,6 +138,26 @@ found:
     return 0;
   }
 
+  // 添加kernel pagetable
+  p->kernelpt = proc_kpt_init();
+  if (p->kernelpt == 0){
+    freeproc(p);
+    release(&p->lock);
+    return 0;
+  }
+
+  // 把内核映射放到到进程的内核栈里
+  // Allocate a page for the process's kernel stack.
+  // Map it high in memory, followed by an invalid
+  // guard page.
+  char *pa = kalloc();
+  if(pa == 0)
+    panic("kalloc");
+  uint64 va = KSTACK((int) (p - proc));
+  // 添加kernel stack的映射到用户的kernel pagetable里
+  uvmmap(p->kernelpt, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
+  p->kstack = va;
+
   // Set up new context to start executing at forkret,
   // which returns to user space.
   memset(&p->context, 0, sizeof(p->context));
@@ -153,8 +176,20 @@ freeproc(struct proc *p)
   if(p->trapframe)
     kfree((void*)p->trapframe);
   p->trapframe = 0;
+  // 删除kernel stack
+  if (p->kstack)
+  {
+    pte_t* pte = walk(p->kernelpt, p->kstack, 0);
+    if (pte == 0)
+      panic("freeproc: kstack");
+    kfree((void*)PTE2PA(*pte));
+  }
+  p->kstack = 0;
   if(p->pagetable)
     proc_freepagetable(p->pagetable, p->sz);
+  // 删除kernel pagetable
+  if (p->kernelpt)
+    proc_freekpt(p->kernelpt);
   p->pagetable = 0;
   p->sz = 0;
   p->pid = 0;
@@ -166,6 +201,30 @@ freeproc(struct proc *p)
   p->state = UNUSED;
 }
 
+// free kernel pagetable
+// 模仿vm.c中的freewalk，但注意物理地址没有释放
+// 最后一层叶节点没有释放，标志位并没有重置
+// 故需要修改一下
+void 
+proc_freekpt(pagetable_t pagetable)
+{
+  // there are 2^9 = 512 PTEs in a page table.
+  for(int i = 0; i < 512; i++){
+    pte_t pte = pagetable[i];
+    if((pte & PTE_V)){
+      pagetable[i] = 0;
+      if ((pte & (PTE_R|PTE_W|PTE_X)) == 0)
+      {
+        uint64 child = PTE2PA(pte);
+        proc_freekpt((pagetable_t)child);
+      }
+    } else if(pte & PTE_V){
+      panic("proc free kpt: leaf");
+    }
+  }
+  kfree((void*)pagetable);
+}
+
 // Create a user page table for a given process,
 // with no user memory, but with trampoline pages.
 pagetable_t
@@ -235,6 +294,8 @@ userinit(void)
   uvminit(p->pagetable, initcode, sizeof(initcode));
   p->sz = PGSIZE;
 
+  uvm_user2ker_copy(p->pagetable, p->kernelpt, 0, p->sz);
+
   // prepare for the very first "return" from kernel to user.
   p->trapframe->epc = 0;      // user program counter
   p->trapframe->sp = PGSIZE;  // user stack pointer
@@ -289,6 +350,9 @@ fork(void)
   }
   np->sz = p->sz;
 
+  uvm_user2ker_copy(np->pagetable, np->kernelpt, 0, np->sz);
+
+
   // copy saved user registers.
   *(np->trapframe) = *(p->trapframe);
 
@@ -445,6 +509,7 @@ scheduler(void)
     // Avoid deadlock by ensuring that devices can interrupt.
     intr_on();
 
+    int found = 0;
     for(p = proc; p < &proc[NPROC]; p++) {
       acquire(&p->lock);
       if(p->state == RUNNABLE) {
@@ -453,14 +518,29 @@ scheduler(void)
         // before jumping back to us.
         p->state = RUNNING;
         c->proc = p;
+        // 将当前进程的kernel page存入stap寄存器中
+        w_satp(MAKE_SATP(p->kernelpt));
+        sfence_vma();
         swtch(&c->context, &p->context);
 
         // Process is done running for now.
         // It should have changed its p->state before coming back.
         c->proc = 0;
+        found = 1;
       }
       release(&p->lock);
     }
+#if !defined (LAB_FS)
+    if(found == 0) {
+      intr_on();
+      // 没有进程在运行则使用内核原来的kernel pagtable
+      w_satp(MAKE_SATP(kernel_pagetable));
+      sfence_vma();
+      asm volatile("wfi");
+    }
+#else
+    ;
+#endif
   }
 }
 
diff --git a/kernel/proc.h b/kernel/proc.h
index f6ca8b7..014eefa 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -100,6 +100,7 @@ struct proc {
   uint64 kstack;               // Virtual address of kernel stack
   uint64 sz;                   // Size of process memory (bytes)
   pagetable_t pagetable;       // User page table
+  pagetable_t kernelpt;        // 内核映射表
   struct trapframe *trapframe; // data page for trampoline.S
   struct context context;      // swtch() here to run process
   struct file *ofile[NOFILE];  // Open files
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3bd0007..fbbfeb2 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -50,6 +50,13 @@ sys_sbrk(void)
   addr = myproc()->sz;
   if(growproc(n) < 0)
     return -1;
+
+  if(n > 0)
+  {
+    uvm_user2ker_copy(myproc()->pagetable, myproc()->kernelpt, addr, addr + n);
+  }
+  //考虑到内核页表内容是根据用户页表改变，所以只增加/覆盖内容，不删除内容
+
   return addr;
 }
 
diff --git a/kernel/vm.c b/kernel/vm.c
index d5a12a0..4b0868a 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -432,3 +432,78 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
     return -1;
   }
 }
+
+
+void _vmprint(pagetable_t pagetable, int level)
+{
+  for(int i = 0; i < 512; i++){
+    pte_t pte = pagetable[i];
+    if((pte & PTE_V)){
+      // this PTE points to a lower-level page table.
+      for (int j = 0; j < level; j++)
+      {
+        if (j == 0) printf("..");
+        else printf(" ..");
+      }
+      uint64 child = PTE2PA(pte);
+      printf("%d: pte %p pa %p\n", i, pte, child);
+      // 查看flag位是否被设置，若被设置则为最低一层，
+      // 见vm.c161行，可以看到只有最底层被设置了符号位
+      if ((pte & (PTE_R|PTE_W|PTE_X)) == 0)
+        _vmprint((pagetable_t)child, level + 1);
+    }
+  }
+}
+
+void vmprint(pagetable_t pagetable)
+{
+  printf("page table %p\n", pagetable);
+  _vmprint(pagetable, 1);
+}
+
+// 模仿vm.c中kvminit的方式构建每个进程自己
+// 的内核映射表 TODO:删除
+pagetable_t proc_kpt_init()
+{
+  pagetable_t kpt;
+  kpt = uvmcreate();
+  if (kpt == 0) return 0;
+  uvmmap(kpt, UART0, UART0, PGSIZE, PTE_R | PTE_W);
+  uvmmap(kpt, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
+  uvmmap(kpt, CLINT, CLINT, 0x10000, PTE_R | PTE_W);
+  uvmmap(kpt, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
+  uvmmap(kpt, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
+  uvmmap(kpt, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
+  uvmmap(kpt, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
+  return kpt;
+}
+
+// 添加映射到用户进程的kernel pagetable
+void uvmmap(pagetable_t pagetable, uint64 va, uint64 pa, uint64 sz, int perm)
+{
+  if(mappages(pagetable, va, sz, pa, perm) != 0)
+    panic("kvmmap");
+}
+
+/*
+先仿照uvmcopy创建一个从用户态页表复制到内核态页表的函数*/
+void
+uvm_user2ker_copy(pagetable_t u, pagetable_t k, uint64 start, uint64 end)
+{
+  
+  pte_t *user;
+  pte_t *kernel;
+  for(uint64 i = start; i < end; i += PGSIZE)
+  {
+    user = walk(u, i, 0);
+    kernel = walk(k, i, 1);
+/*
+	根据内核态页表的特点--直接映射到物理内存
+	我们无需使用mappage建立映射
+	记得消除PTE_U标志位
+*/
+    *kernel = (*user) & (~PTE_U);
+  }
+
+}
+
